<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Palm Rasengan with Particles</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #output-canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
    </style>
</head>
<body>
    <video id="input-video" style="display: none;"></video>
    <canvas id="output-canvas"></canvas>

    <script>
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function resizeCanvas() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        let rotation = 0;
        let particles = [];

        class Particle {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = Math.max(radius, 0.1);
                this.baseRadius = this.radius;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 0.05 + Math.random() * 0.1;
            }

            update() {
                this.angle += this.speed;
                this.radius = Math.max(this.baseRadius + Math.sin(this.angle) * 2, 0.1);
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, Math.max(this.radius, 0.1), 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(100, 149, 237, 0.7)';
                ctx.fill();
            }
        }

        function drawRasengan(ctx, x, y, radius) {
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.2, 'rgba(100, 149, 237, 0.8)');
            gradient.addColorStop(1, 'rgba(0, 0, 139, 0.8)');

            ctx.save();
            ctx.translate(x, y);

            for (let i = 0; i < 5; i++) {
                ctx.save();
                ctx.rotate(rotation + i * Math.PI / 2.5);
                ctx.scale(1, 0.6);
                ctx.beginPath();
                ctx.arc(0, 0, radius * (1 - i * 0.15), 0, Math.PI * 2);
                ctx.fillStyle = `rgba(100, 149, 237, ${0.2 - i * 0.04})`;
                ctx.fill();
                ctx.restore();
            }

            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            for (let i = 0; i < 8; i++) {
                ctx.save();
                ctx.rotate(rotation * (i % 2 ? 1 : -1));
                ctx.beginPath();
                ctx.arc(0, 0, radius * 0.8, 0, Math.PI);
                ctx.lineWidth = 3;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();

            particles.forEach(particle => {
                particle.update();
                particle.draw(ctx);
            });

            if (particles.length < 50) {
                const angle = Math.random() * Math.PI * 2;
                const distance = radius * (0.8 + Math.random() * 0.4);
                particles.push(new Particle(
                    x + Math.cos(angle) * distance,
                    y + Math.sin(angle) * distance,
                    Math.max(1 + Math.random() * 2, 0.1)
                ));
            }

            particles = particles.filter(p =>
                Math.hypot(p.x - x, p.y - y) < radius * 1.5
            );
        }

        hands.onResults((results) => {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            const aspectRatio = results.image.width / results.image.height;
            let drawWidth, drawHeight, offsetX, offsetY;

            if (canvasElement.width / canvasElement.height > aspectRatio) {
                drawWidth = canvasElement.width;
                drawHeight = canvasElement.width / aspectRatio;
                offsetX = 0;
                offsetY = (canvasElement.height - drawHeight) / 2;
            } else {
                drawHeight = canvasElement.height;
                drawWidth = canvasElement.height * aspectRatio;
                offsetX = (canvasElement.width - drawWidth) / 2;
                offsetY = 0;
            }

            canvasCtx.drawImage(results.image, offsetX, offsetY, drawWidth, drawHeight);

            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    const palmCenter = {
                        x: (landmarks[0].x + landmarks[5].x + landmarks[9].x + landmarks[13].x + landmarks[17].x) / 5,
                        y: (landmarks[0].y + landmarks[5].y + landmarks[9].y + landmarks[13].y + landmarks[17].y) / 5
                    };

                    drawRasengan(
                        canvasCtx,
                        palmCenter.x * drawWidth + offsetX,
                        palmCenter.y * drawHeight + offsetY,
                        70
                    );
                }
            }

            canvasCtx.restore();
        });

        function animate() {
            rotation += 0.05;
            requestAnimationFrame(animate);
        }
        animate();

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720,
            facingMode: { exact: "environment" }
        });
        camera.start();
    </script>
</body>
</html>