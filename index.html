<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hand Palm Rasengan with Particles</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #input-video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #output-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <video id="input-video" autoplay playsinline></video>
    <canvas id="output-canvas"></canvas>

    <script>
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');

        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: canvasElement, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Rasengan sphere
        const rasenganGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const rasenganMaterial = new THREE.MeshPhongMaterial({
            color: 0x6495ED,
            transparent: true,
            opacity: 0.8,
            shininess: 100
        });
        const rasenganSphere = new THREE.Mesh(rasenganGeometry, rasenganMaterial);
        scene.add(rasenganSphere);

        // Particles
        const particleCount = 500;
        const particlesGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
            const r = 0.6 + Math.random() * 0.2;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            particlePositions[i] = r * Math.sin(phi) * Math.cos(theta);
            particlePositions[i + 1] = r * Math.sin(phi) * Math.sin(theta);
            particlePositions[i + 2] = r * Math.cos(phi);
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

        const particlesMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 0.02,
            transparent: true,
            opacity: 0.7
        });

        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        camera.position.z = 5;

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        let lastZPosition = 0;
        const smoothingFactor = 0.1;

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const palmCenter = {
                    x: (landmarks[0].x + landmarks[5].x + landmarks[9].x + landmarks[13].x + landmarks[17].x) / 5,
                    y: (landmarks[0].y + landmarks[5].y + landmarks[9].y + landmarks[13].y + landmarks[17].y) / 5,
                    z: (landmarks[0].z + landmarks[5].z + landmarks[9].z + landmarks[13].z + landmarks[17].z) / 5
                };

                lastZPosition = lastZPosition * (1 - smoothingFactor) + palmCenter.z * smoothingFactor;

                const baseScale = 1;
                const scaleMultiplier = 1 + lastZPosition * 3;
                const newScale = baseScale * scaleMultiplier;

                rasenganSphere.position.set(
                    (palmCenter.x - 0.5) * 10,
                    -(palmCenter.y - 0.5) * 10,
                    -lastZPosition * 5
                );
                rasenganSphere.scale.set(newScale, newScale, newScale);

                particles.position.copy(rasenganSphere.position);
                particles.scale.set(newScale, newScale, newScale);
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            rasenganSphere.rotation.x += 0.01;
            rasenganSphere.rotation.y += 0.01;

            particles.rotation.x += 0.5;
            particles.rotation.y += 0.5;

            renderer.render(scene, camera);
        }
        animate();

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720,
            facingMode: { exact: "environment" }
        });
        cameraUtils.start();

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        canvasElement.addEventListener('mousedown', (event) => {
            isDragging = true;
        });

        canvasElement.addEventListener('mouseup', (event) => {
            isDragging = false;
        });

        canvasElement.addEventListener('mousemove', (event) => {
            if (isDragging) {
                const deltaMove = {
                    x: event.offsetX - previousMousePosition.x,
                    y: event.offsetY - previousMousePosition.y
                };

                rasenganSphere.rotation.y += deltaMove.x * 0.01;
                rasenganSphere.rotation.x += deltaMove.y * 0.01;

                particles.rotation.y += deltaMove.x * 0.01;
                particles.rotation.x += deltaMove.y * 0.01;
            }

            previousMousePosition = {
                x: event.offsetX,
                y: event.offsetY
            };
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>